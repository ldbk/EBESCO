---
title: "Modélisation de la distribution d'espèces d'intérêt commercial à partir des données de campagne CGFS"
date: "`r Sys.Date()`"
output: 
  rmdformats::downcute:
  highlight: zenburn
html_document :
  toc: true
toc_float: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = getwd())                                # garde le working dir actif
knitr::opts_knit$set(envir = globalenv())                               # utilise l'env global
knitr::opts_chunk$set(echo = FALSE, message=FALSE,warning=FALSE)
```


# 1. Données

 <br/>
 
### Domaine d'étude et espèce

```{r echo=FALSE}

print(study_domain)

print(sp_scientific)

```
<br/>

Echantillonnage annuel dans toute la Manche à partir de 2018.

<br/>
<br/>
  
```{r echo=FALSE, warning=FALSE}

# Load the appropriate shapefile depending on the study domain
if (study_domain == "Entire_English_Channel") {
  EC_shp <- vect(here("01_DATA", "shapefiles", "English_Channel", "English_Channel.shp"))
}

if (study_domain == "Eastern_English_Channel") {
  EC_shp <- vect(here("01_DATA", "shapefiles", "Eastern_English_Channel", "Eastern_English_Channel.shp"))
}

# Convert the shapefile to an sf object in WGS84
EC_sf <- st_as_sf(EC_shp) %>% st_transform(4326)

# Plot presence/absence + biomass density if the model includes a density component
if (response == "densityKgKm2") {               
basemap(data = EC_sf, land.col = "grey80", land.border = "grey80") +   
  geom_sf(data = EC_sf, fill = NA, color= NA) +        
  geom_spatial_point(data = data_CGFS_crs, 
                     aes(x = lon, y = lat, 
                         color = factor(presence_absence), 
                         size  = densityKgKm2), 
                     alpha = 0.6) +
  scale_color_manual(values = c("0" = "red", "1" = "blue"), 
                     labels = c("Absence", "Présence"), 
                     name   ="Présence") +
  scale_size_continuous(name ="Densité de\nbiomasse\n(kg/km²)") +
  facet_wrap(~ year) +
  theme(panel.grid = element_blank(),
        panel.border = element_rect(color = "white", fill = NA, linewidth = 1),
        strip.background = element_rect(fill = "grey40", color = "white"),
        strip.text = element_text(color = "white", face = "bold"))+
  ggtitle(bquote("Distribution spatiale de la densité de " * italic(.(sp_scientific)) * " entre 2018 et 2024 (campagne CGPS)"))+
  labs(x="", y="")
}


# if (response == "densityKgKm2") {               
# basemap(data = EC_sf, land.col = "grey80", land.border = "grey80") +   
#   geom_sf(data = EC_sf, fill = NA, color= NA) +        
#   geom_spatial_point(data = data_CGFS_crs, 
#                      aes(x = lon, y = lat, 
#                          color = factor(presence_absence), 
#                          shape = factor(presence_absence),
#                          size  = densityKgKm2), 
#                      alpha = 0.6, stroke = 1) +
#   scale_color_manual(values = c("0" = "black", "1" = "black"), 
#                      labels = c("Absence", "Présence"), 
#                      name   = "Présence") +
#   scale_shape_manual(values = c("0" = 4, "1" = 16),       # 88 = croix X   / 16 = point plein
#                      labels = c("Absence", "Présence"),
#                      name   = "Présence") +
#   scale_size_continuous(name ="Densité de\nbiomasse\n(kg/km²)") +
#   facet_wrap(~ year) +
#   theme(panel.grid = element_blank(),
#         panel.border = element_rect(color = "white", fill = NA, linewidth = 1),
#         strip.background = element_rect(fill = "grey40", color = "white"),
#         strip.text = element_text(color = "white", face = "bold"))+
#   ggtitle(bquote("Distribution spatiale de la densité de " * italic(.(sp_scientific)) * " entre 2018 et 2024 (campagne CGPS)"))+
#   labs(x="", y="")
# }

# Plot presence/absence if the model includes a presence component
if (response == "presence_absence") {               
basemap(data = EC_sf, land.col = "grey80", land.border = "grey80") +   
  geom_sf(data = EC_sf, fill = NA, color= NA) +        
  geom_spatial_point(data = data_CGFS_crs, 
                     aes(x = lon, y = lat, color = factor(presence_absence)), 
                     alpha = 0.6) +
  scale_color_manual(values = c("0" = "red", "1" = "blue"), 
                     labels = c("Absence", "Présence"), 
                     name   ="Présence") +
  facet_wrap(~ year) +
  theme(panel.grid = element_blank(),
        panel.border = element_rect(color = "white", fill = NA, linewidth = 1),
        strip.background = element_rect(fill = "grey40", color = "white"),
        strip.text = element_text(color = "white", face = "bold"))+
  ggtitle(bquote("Distribution spatiale de la présence de " * italic(.(sp_scientific)) * " entre 2018 et 2024 (campagne CGPS)"))+
    labs(x="", y="")

}

```

<br/>

```{r echo=FALSE}

# map CGFS station depths by year 

if (isTRUE(depth_FE)) {               

basemap(data = EC_sf, land.col = "grey80", land.border = "grey80") +   
  geom_sf(data = EC_sf, fill = NA, color= NA) +        
  geom_spatial_point(data = data_CGFS_crs, 
                     aes(x = lon, y = lat, color = depth), alpha = 0.8) +
  scale_color_viridis_c(option = "magma", direction = -1, name = "Profondeur (m)") +
  facet_wrap(~ year) +
  theme(panel.grid = element_blank(),
        panel.border = element_rect(color = "white", fill = NA, linewidth = 1),
        strip.background = element_rect(fill = "grey40", color = "white"),
        strip.text = element_text(color = "white", face = "bold"))+
  labs(title = "Profondeur aux stations CGFS", x = "", y = "") 

}

```

```{r echo=FALSE}

# map CGFS station substrate by year 

if (isTRUE(substrate_factor_FE)) {               

data_CGFS_crs$substrate_txt <- factor(data_CGFS_crs$substrate,
                                      levels = 1:5,
                                      labels = c("Vase à sable vaseux",
                                                 "Sable",
                                                 "Sédiments grossiers",
                                                 "Sédiments mixtes",
                                                 "Roches et blocs"))

substrate_palette_txt <- c("Vase à sable vaseux" = "#CC99CC",
                           "Sable" = "#fdb462",
                           "Sédiments grossiers" = "#7fc97f",
                           "Sédiments mixtes" = "#80b1d3",
                           "Roches et blocs" = "#fb8072")

basemap(data = EC_sf, land.col = "grey80", land.border = "grey80") +   
  geom_sf(data = EC_sf, fill = NA, color= NA) +        
  geom_spatial_point(data = data_CGFS_crs, 
                     aes(x = lon, y = lat, color = factor(substrate_txt))) +
  facet_wrap(~ year) +
  scale_color_manual(values = substrate_palette_txt) +
  theme(panel.grid = element_blank(),
        panel.border = element_rect(color = "white", fill = NA, linewidth = 1),
        strip.background = element_rect(fill = "grey40", color = "white"),
        strip.text = element_text(color = "white", face = "bold"))+
  labs(title = "Nature du substrat aux stations CGFS", x = "", y = "", color = "Nature du substrat")  

}

```


# 2. Mesh 

```{r echo=FALSE}

# Copy the mesh object
mesh_m <- mesh$mesh

# Convert mesh coordinates from kilometers to meters
mesh_m$loc <- mesh_m$loc * 1000 

# Compute the mesh bounding box in meters
mesh_m_bbox <- st_bbox(c(xmin = min(mesh_m$loc[, 1]),
                         xmax = max(mesh_m$loc[, 1]),
                         ymin = min(mesh_m$loc[, 2]),
                         ymax = max(mesh_m$loc[, 2])), crs = utm_crs_used)

# Build "land_mesh" containing coastlines cropped to the mesh extent
land_mesh <- ne_countries(scale = "large",
                     country = c("United Kingdom", "France"),
                     returnclass = "sf") %>%
  st_transform(utm_crs_used) %>%
  st_crop(mesh_m_bbox)

# Separate water triangles and land (barrier) triangles
mesh_df_water <- bspde$mesh_sf[bspde$normal_triangles, ]
mesh_df_land  <- bspde$mesh_sf[bspde$barrier_triangles, ]

# Plot the mesh, land areas, and triangle centers
ggplot() +
  geom_sf(data = land_mesh, fill = "grey80", color = NA) +
  gg(mesh_m, edge.color = "grey50", edge.linewidth = 0.2) +
  geom_sf(data = mesh_df_water, size = 1, colour = "blue") +
  geom_sf(data = mesh_df_land,  size = 1, colour = "red") +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3))+
  scale_x_continuous(breaks = scales::pretty_breaks(n = 4))+
  coord_sf(crs = st_crs(land_mesh)) +
  theme_minimal() +
  theme(panel.grid = element_blank(),
        axis.ticks = element_line(colour = "black"))+
  labs(x="", y="", title = paste0("Maillage triangulaire avec cutoff de ", cutoff, "km"), 
       subtitle = "rouge = centre des triangles sur la terre\nbleu = centre des triangles en mer")



```
 <br/>  
Le cutoff définit la distance minimale autorisée entre les sommets du maillage triangulaire (en km).  

Dans la figure, les points bleus correspondent aux centres des triangles situés en mer, tandis que les croix rouges indiquent les centres des triangles positionnés sur la terre.  
Dans les triangles terrestres, la portée spatiale sera réduite à 10 % de celle utilisée en mer (range_fraction = 0.1).  
  
Ainsi, lorsque le modèle est ajusté avec cette nouvelle mesh, la présence d’une barrière (la terre) est automatiquement prise en compte dans la structure de corrélation spatiale.

<br/>  
<br/>  

# 3. Modèle

## 3.1. Formule
```{r}
print(model_formula)
```

```{r}
print(distribution_family)
```

 <br/>
<br/> 


## 3.2. Diagnostic

```{r sanity, echo=FALSE, message=TRUE}
sanity(model)
```
 
 <br/>
sigma_E : écart-type du processus spatio-temporel (epsilon)
 <br/>  
 <br/> 
 
```{r}
print(summary(model))
```

 <br/>
 
Matérn range : distance au-delà de laquelle deux points sont considérés comme effectivement indépendants (la corrélation spatiale devient négligeable, ~0.13 correlation)


 <br/>
 <br/>

### Intervalles de confiance des effets fixes
```{r}
print(tidy(model,conf.int = TRUE))
```
 
 <br/>
 
### Intervalles de confiance des effets aléatoires et paramètres de variance
```{r}
print(tidy(model,'ran_pars',conf.int = TRUE))
```
  
 <br/>
* range : distance au-delà de laquelle deux points sont considérés comme effectivement indépendants  
* phi : paramètre de dispersion d'une distribution (variabilité des données autour de la moyenne --> détermine à quel point les observations sont plus ou moins dispersées que ce que prédit un modèle) 
* sigma_O : écart-type marginal du champ aléatoire spatial (omega) : mesure l’amplitude moyenne de la variation spatiale qui ne changent pas dans le temps et qui ne sont pas expliquées par le modèle (plus il est faible, plus les covariables expliquent bien la structure spatiale)  
* sigma_E : écart-type marginal du champ spatio-temporel (epsilon) : mesure l’amplitude moyenne des variations spatiales qui changent dans le temps et qui ne sont pas expliquées par le modèle (plus il est faible, la structure spatio-temporelle est déjà bien capturée par les autres composantes du modèle)  

  


## 3.3. Résidus

<br/>

```{r echo=FALSE}

data_test_model$residuals <- residuals(model)
qqnorm(data_test_model$residuals)
qqline(data_test_model$residuals)

```

<br/>

### Tests statistiques DHARMa standards sur les résidus : uniformité, dispersion et valeurs aberrantes

```{r echo=FALSE}

ggplot(data_test_model, aes(lon, lat, fill = residuals)) +
  scale_fill_gradient2() +
  geom_point(color = "grey", size = 2, shape = 21) +
  facet_wrap(~year) + 
  labs(x="", y="")

```
  
 <br/>
Des schémas spatiaux marqués suggèrent l’absence de covariables pertinentes ou un maillage trop grossier.

<br/>
<br/>


```{r echo=FALSE}

# Simule 500 jeux de données à partir du modèle ajusté, en tenant compte de l’incertitude 
# sur les paramètres via une approximation normale multivariée autour du MLE
model_sim <- simulate(model, nsim = 1000, type = "mle-mvn") 

# "mle-mvn" : les effets fixes sont aux MLE, mais les effets aléatoires sont tirés d’un 
# échantillon approximatif unique. Cette option est recommandée lorsque les simulations sont 
# utilisées pour des tests de qualité d’ajustement avec le package DHARMa.

simulationOutput <- dharma_residuals(model_sim, model, return_DHARMa = TRUE)

plot(simulationOutput)

# DHARMa general residual test : Calls uniformity, dispersion and outliers tests.
DHARMa::testResiduals(simulationOutput,plot=TRUE)

```

Simulation de 500 jeux de données à partir du modèle ajusté, en tenant compte de l’incertitude sur les paramètres via une approximation normale multivariée autour du maximum de vraisemblance

Si les données sont cohérentes avec les hypothèses du modèle, ces résidus doivent suivre une loi normale centrée réduite N(0,1).

Test d'uniformité 
teste des résidus si la distribution globale est conforme aux attentes

Test de dispersion 
teste si la dispersion simulée est égale à la dispersion observée

Test outliers
teste s’il y a plus de valeurs aberrantes issues des simulations que prévu



# 4. Grille de projection

```{r echo=FALSE}

# plot projection grid


if (!isTRUE(depth_FE)) {               

ggplot(grid_pred, aes(lon, lat)) +
  geom_tile(width = res_deg_lon, height = res_deg_lat, color = "black", fill = "white") +
  geom_sf(data=land, fill="grey80", inherit.aes = FALSE, color = NA) +
  coord_sf(xlim = c(xmin_plot, xmax_plot), 
           ylim = c(ymin_plot, ymax_plot), 
           expand = FALSE) +
  theme(panel.grid = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA), 
        panel.border = element_rect(color = "white", fill = NA, linewidth = 2),
        strip.background = element_rect(fill = "grey40", color = "white"),
        strip.text = element_text(color = "white", face = "bold"))+
  labs(x = "", y = "") +
  ggtitle(bquote("Grille de projection (résolution de " *.(res_km)* " km)"))

} 


if (isTRUE(depth_FE)) {               

ggplot(grid_pred, aes(lon, lat, fill = depth)) + 
  geom_raster() +
  geom_sf(data=land, fill="grey80", inherit.aes = FALSE, color = NA) +
  scale_fill_viridis_c(option = "viridis", direction = -1)+
  coord_sf(xlim = c(xmin_plot, xmax_plot), 
           ylim = c(ymin_plot, ymax_plot), 
           expand = FALSE) +
  theme(panel.grid = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA), 
        panel.border = element_rect(color = "white", fill = NA, linewidth = 2),
        strip.background = element_rect(fill = "grey40", color = "white"),
        strip.text = element_text(color = "white", face = "bold"))+
  labs(x = "", y ="", fill = "Profondeur (m)")+
  ggtitle(bquote("Grille de projection avec profondeur aggrégée à une résolution de " *.(res_km)* "km"))

}

```


```{r echo=FALSE}

if (isTRUE(substrate_factor_FE)) {               

  substrate_labels <- c("1" = "Vase à sable vaseux",
                        "2" = "Sable",
                        "3" = "Sédiments grossiers",
                        "4" = "Sédiments mixtes",
                        "5" = "Roches et blocs")
    
  substrate_palette <- c("1" = "#CC99CC",
                         "2" = "#fdb462",
                         "3" = "#7fc97f",
                         "4" = "#80b1d3",
                         "5" = "#fb8072")
  
  plot_before <- ggplot(grid_substrate_before, aes(lon, lat, fill = factor(substrate))) +
    geom_tile() +
    geom_sf(data=land, fill="grey80", inherit.aes = FALSE, color = NA) +
    coord_sf(xlim = c(xmin_plot, xmax_plot), 
             ylim = c(ymin_plot, ymax_plot), 
             expand = FALSE) +
    theme(panel.grid = element_blank(),
          panel.background = element_rect(fill = "white", colour = NA), 
          panel.border = element_rect(color = "white", fill = NA, linewidth = 2),
          strip.background = element_rect(fill = "grey40", color = "white"),
          strip.text = element_text(color = "white", face = "bold"))+
    scale_fill_manual(values = substrate_palette,
                      labels = unname(substrate_labels)) +
    labs(title = "Cartographie des classes de substrat",
    subtitle = "AVANT traitement des cellules de nature 'Roches et blocs' sans données d’échantillonnage", 
    x="", y="", fill = "Nature du substrat")
  
  plot_after <- ggplot(grid_substrate_after, aes(lon, lat, fill = factor(substrate))) +
    geom_tile() +
    geom_sf(data=land, fill="grey80", inherit.aes = FALSE, color = NA) +
    coord_sf(xlim = c(xmin_plot, xmax_plot), 
             ylim = c(ymin_plot, ymax_plot), 
             expand = FALSE) +
    theme(panel.grid = element_blank(),
          panel.background = element_rect(fill = "white", colour = NA), 
          panel.border = element_rect(color = "white", fill = NA, linewidth = 2),
          strip.background = element_rect(fill = "grey40", color = "white"),
          strip.text = element_text(color = "white", face = "bold"))+
        scale_fill_manual(values = substrate_palette,
                      labels = unname(substrate_labels)) +
    labs(subtitle = "APRES traitement des cellules de nature 'Roches et blocs' sans données d’échantillonnage", 
    x="", y="", fill = "Nature du substrat")



  ggpubr::ggarrange(plot_before, 
                    plot_after, 
                    ncol = 1, 
                    common.legend = TRUE, legend = "right")
  
}

```
                    
```{r echo=FALSE}

# plot projection grid

if (isTRUE(substrate_factor_FE)) {               

ggplot(grid_pred, aes(lon, lat, fill = factor(substrate))) + 
  geom_raster() +
  geom_sf(data=land, fill="grey80", inherit.aes = FALSE, color = NA) +
  coord_sf(xlim = c(xmin_plot, xmax_plot), 
           ylim = c(ymin_plot, ymax_plot), 
           expand = FALSE) +
  scale_fill_manual(values = substrate_palette,
                   labels = unname(substrate_labels)) +
  theme(panel.grid = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA), 
        panel.border = element_rect(color = "white", fill = NA, linewidth = 2),
        strip.background = element_rect(fill = "grey40", color = "white"),
        strip.text = element_text(color = "white", face = "bold"))+
  labs(x = "", y ="", fill = "Substrat")+
  ggtitle(bquote("Grille de projection avec effet substrat à une résolution de " *.(res_km)* "km"))

}

```


```{r echo=FALSE}

# plot projection grid

if (isTRUE(gear_factor_FE)) {               

ggplot(grid_pred, aes(lon, lat, fill = gear)) + 
  geom_raster() +
  geom_sf(data=land, fill="grey80", inherit.aes = FALSE, color = NA) +
  coord_sf(xlim = c(xmin_plot, xmax_plot), 
           ylim = c(ymin_plot, ymax_plot), 
           expand = FALSE) +
  theme(panel.grid = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA), 
        panel.border = element_rect(color = "white", fill = NA, linewidth = 2),
        strip.background = element_rect(fill = "grey40", color = "white"),
        strip.text = element_text(color = "white", face = "bold"))+
  labs(x = "", y ="", fill = "Engin")+
  ggtitle(bquote("Grille de projection avec effet engin à une résolution de " *.(res_km)* "km"))

}

```


# 5. Prédictions

## Effets fixes + aléatoires spatiaux + aléatoires spatio-temporels

```{r echo=FALSE}

if (response == "presence_absence") {               

ggplot(pred_fit, aes(lon, lat, fill = est)) + 
  geom_raster() +
  facet_wrap(~year) +
  geom_sf(data=land, fill="grey80", inherit.aes = FALSE, color = "grey80") +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3))+
  scale_x_continuous(breaks = scales::pretty_breaks(n = 4))+
  scale_fill_viridis_c(option = "magma", 
                       labels = scales::label_number(drop0trailing = TRUE))+
  coord_sf(xlim = c(xmin_plot, xmax_plot), 
           ylim = c(ymin_plot, ymax_plot), 
           expand = FALSE) +
  theme(panel.grid = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA), 
        panel.border = element_rect(color = "white", fill = NA, linewidth = 2),
        strip.background = element_rect(fill = "grey40", color = "white"),
        strip.text = element_text(color = "white", face = "bold"))+
        ggtitle(bquote("Distribution spatiale de " * italic(.(sp_scientific)) * ""))+
  labs(x = "", y ="", 
       subtitle = "Effets fixes + aléatoires spatiaux + aléatoires spatio-temporels")

}

if (response == "densityKgKm2" && distribution_family == "tweedie") {               

ggplot(pred_fit, aes(lon, lat, fill = est)) + 
  geom_raster() +
  facet_wrap(~year) +
  geom_sf(data=land, fill="grey80", inherit.aes = FALSE, color = "grey80") +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3))+
  scale_x_continuous(breaks = scales::pretty_breaks(n = 4))+
  scale_fill_viridis_c(option = "magma", 
                       labels = scales::label_number(drop0trailing = TRUE))+
    coord_sf(xlim = c(xmin_plot, xmax_plot), 
           ylim = c(ymin_plot, ymax_plot), 
           expand = FALSE) +
  theme(panel.grid = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA), 
        panel.border = element_rect(color = "white", fill = NA, linewidth = 2),
        strip.background = element_rect(fill = "grey40", color = "white"),
        strip.text = element_text(color = "white", face = "bold"))+
        ggtitle(bquote("Distribution spatiale de la densité de biomasse de " * 
                         italic(.(sp_scientific)) * ""))+
  labs(x = "", y ="", 
       subtitle = "Effets fixes + aléatoires spatiaux + aléatoires spatio-temporels")

}

if (response == "densityKgKm2" && distribution_family != "tweedie") {               

ggplot(pred_fit, aes(lon, lat, fill = est1)) + 
  geom_raster() +
  facet_wrap(~year) +
  geom_sf(data=land, fill="grey80", inherit.aes = FALSE, color = "grey80") +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3))+
  scale_x_continuous(breaks = scales::pretty_breaks(n = 4))+
  scale_fill_viridis_c(option = "magma", 
                       labels = scales::label_number(drop0trailing = TRUE))+
    coord_sf(xlim = c(xmin_plot, xmax_plot), 
           ylim = c(ymin_plot, ymax_plot), 
           expand = FALSE) +
  theme(panel.grid = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA), 
        panel.border = element_rect(color = "white", fill = NA, linewidth = 2),
        strip.background = element_rect(fill = "grey40", color = "white"),
        strip.text = element_text(color = "white", face = "bold"))+
        ggtitle(bquote("Distribution spatiale de la densité de biomasse de " * 
                         italic(.(sp_scientific)) * ""))+
  labs(x = "", y ="", 
       subtitle = "Effets fixes + aléatoires spatiaux + aléatoires spatio-temporels")

}
```

```{r echo=FALSE}

if (response == "densityKgKm2" && distribution_family != "tweedie") {               

ggplot(pred_fit, aes(lon, lat, fill = est2)) + 
  geom_raster() +
  facet_wrap(~year) +
  geom_sf(data=land, fill="grey80", inherit.aes = FALSE, color = "grey80") +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3))+
  scale_x_continuous(breaks = scales::pretty_breaks(n = 4))+
  scale_fill_viridis_c(option = "magma", 
                       labels = scales::label_number(drop0trailing = TRUE))+
    coord_sf(xlim = c(xmin_plot, xmax_plot), 
           ylim = c(ymin_plot, ymax_plot), 
           expand = FALSE) +
  theme(panel.grid = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA), 
        panel.border = element_rect(color = "white", fill = NA, linewidth = 2),
        strip.background = element_rect(fill = "grey40", color = "white"),
        strip.text = element_text(color = "white", face = "bold"))+
        ggtitle(bquote("Distribution spatiale de la densité de biomasse de " * 
                         italic(.(sp_scientific)) * ""))+
  labs(x = "", y ="", 
       subtitle = "Effets fixes + aléatoires spatiaux + aléatoires spatio-temporels")

}

```

<br/>

## Effets fixes uniquement

```{r echo=FALSE}

if (response == "presence_absence") {
  ggplot(pred_fit, aes(lon, lat, fill = est_non_rf)) + 
  geom_raster() +
  facet_wrap(~year)+
  geom_sf(data=land, fill="grey80", inherit.aes = FALSE, color = "grey80") +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3))+
  scale_x_continuous(breaks = scales::pretty_breaks(n = 4))+
  scale_fill_viridis_c(option = "magma", 
                       labels = scales::label_number(drop0trailing = TRUE))+
  coord_sf(xlim = c(xmin_plot, xmax_plot), 
           ylim = c(ymin_plot, ymax_plot), 
           expand = FALSE) +
  theme(panel.grid = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA), 
        panel.border = element_rect(color = "white", fill = NA, linewidth = 2),
        strip.background = element_rect(fill = "grey40", color = "white"),
        strip.text = element_text(color = "white", face = "bold"))+
  labs(x = "", y ="", 
       title = "Effets fixes uniquement")
  
}

if (response == "densityKgKm2" && distribution_family == "tweedie") {               
  ggplot(pred_fit, aes(lon, lat, fill = est_non_rf)) + 
  geom_raster() +
  facet_wrap(~year)+
  geom_sf(data=land, fill="grey80", inherit.aes = FALSE, color = "grey80") +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3))+
  scale_x_continuous(breaks = scales::pretty_breaks(n = 4))+
  scale_fill_viridis_c(option = "magma", 
                       labels = scales::label_number(drop0trailing = TRUE))+
  coord_sf(xlim = c(xmin_plot, xmax_plot), 
           ylim = c(ymin_plot, ymax_plot), 
           expand = FALSE) +
  theme(panel.grid = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA), 
        panel.border = element_rect(color = "white", fill = NA, linewidth = 2),
        strip.background = element_rect(fill = "grey40", color = "white"),
        strip.text = element_text(color = "white", face = "bold"))+
  labs(x = "", y ="", 
       title = "Effets fixes uniquement")
}

if (response == "densityKgKm2" && distribution_family != "tweedie") {               
  ggplot(pred_fit, aes(lon, lat, fill = est_non_rf1)) + 
  geom_raster() +
  facet_wrap(~year)+
  geom_sf(data=land, fill="grey80", inherit.aes = FALSE, color = "grey80") +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3))+
  scale_x_continuous(breaks = scales::pretty_breaks(n = 4))+
  scale_fill_viridis_c(option = "magma", 
                       labels = scales::label_number(drop0trailing = TRUE))+
  coord_sf(xlim = c(xmin_plot, xmax_plot), 
           ylim = c(ymin_plot, ymax_plot), 
           expand = FALSE) +
  theme(panel.grid = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA), 
        panel.border = element_rect(color = "white", fill = NA, linewidth = 2),
        strip.background = element_rect(fill = "grey40", color = "white"),
        strip.text = element_text(color = "white", face = "bold"))+
  labs(x = "", y ="", 
       title = "Effets fixes uniquement")
}

```
```{r echo=FALSE}

if (response == "densityKgKm2" && distribution_family != "tweedie") {               
  ggplot(pred_fit, aes(lon, lat, fill = est_non_rf2)) + 
  geom_raster() +
  facet_wrap(~year)+
  geom_sf(data=land, fill="grey80", inherit.aes = FALSE, color = "grey80") +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3))+
  scale_x_continuous(breaks = scales::pretty_breaks(n = 4))+
  scale_fill_viridis_c(option = "magma", 
                       labels = scales::label_number(drop0trailing = TRUE))+
  coord_sf(xlim = c(xmin_plot, xmax_plot), 
           ylim = c(ymin_plot, ymax_plot), 
           expand = FALSE) +
  theme(panel.grid = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA), 
        panel.border = element_rect(color = "white", fill = NA, linewidth = 2),
        strip.background = element_rect(fill = "grey40", color = "white"),
        strip.text = element_text(color = "white", face = "bold"))+
  labs(x = "", y ="", 
       title = "Effets fixes uniquement")
}

```
<br/>

Effets fixes uniquement : utiliser pour comprendre le signal porté par les covariables  
Prédiction issue uniquement des covariables incluses dans le modèle

<br/>
<br/>

```{r echo=FALSE}

if (response == "presence_absence" || distribution_family == "tweedie") {               

ggplot(pred_fit, aes(lon, lat, fill = omega_s)) + 
  geom_raster() +
  geom_sf(data=land, fill="grey80", inherit.aes = FALSE, color = "grey80") +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3))+
  scale_x_continuous(breaks = scales::pretty_breaks(n = 4))+
  scale_fill_gradient2(labels = scales::label_number(drop0trailing = TRUE))+
  coord_sf(xlim = c(xmin_plot, xmax_plot), 
           ylim = c(ymin_plot, ymax_plot), 
           expand = FALSE) +
  theme(panel.grid = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA), 
        panel.border = element_rect(color = "white", fill = NA, linewidth = 2),
        strip.background = element_rect(fill = "grey40", color = "white"),
        strip.text = element_text(color = "white", face = "bold"))+
  labs(x = "", y ="", 
       title = "Effects aléatoires spatiaux seulement")
}

if (response == "densityKgKm2" && distribution_family != "tweedie") {               

ggplot(pred_fit, aes(lon, lat, fill = omega_s1)) + 
  geom_raster() +
  geom_sf(data=land, fill="grey80", inherit.aes = FALSE, color = "grey80") +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3))+
  scale_x_continuous(breaks = scales::pretty_breaks(n = 4))+
  scale_fill_gradient2(labels = scales::label_number(drop0trailing = TRUE))+
  coord_sf(xlim = c(xmin_plot, xmax_plot), 
           ylim = c(ymin_plot, ymax_plot), 
           expand = FALSE) +
  theme(panel.grid = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA), 
        panel.border = element_rect(color = "white", fill = NA, linewidth = 2),
        strip.background = element_rect(fill = "grey40", color = "white"),
        strip.text = element_text(color = "white", face = "bold"))+
  labs(x = "", y ="", 
       title = "Effects aléatoires spatiaux seulement")
}

```

```{r echo=FALSE}

if (response == "densityKgKm2" && distribution_family != "tweedie") {               

ggplot(pred_fit, aes(lon, lat, fill = omega_s2)) + 
  geom_raster() +
  geom_sf(data=land, fill="grey80", inherit.aes = FALSE, color = "grey80") +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3))+
  scale_x_continuous(breaks = scales::pretty_breaks(n = 4))+
  scale_fill_gradient2(labels = scales::label_number(drop0trailing = TRUE))+
  coord_sf(xlim = c(xmin_plot, xmax_plot), 
           ylim = c(ymin_plot, ymax_plot), 
           expand = FALSE) +
  theme(panel.grid = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA), 
        panel.border = element_rect(color = "white", fill = NA, linewidth = 2),
        strip.background = element_rect(fill = "grey40", color = "white"),
        strip.text = element_text(color = "white", face = "bold"))+
  labs(x = "", y ="", 
       title = "Effects aléatoires spatiaux seulement")
}

```

<br/>

Les effets aléatoires spatiaux représentent les effets spatialement corrélés provenant de variables constantes dans le temps mais omises du modèle (déviations constantes dans l’espace au fil du temps, non expliquées par les effets fixes).  
Ces déviations reflètent des facteurs biotiques et abiotiques à structure spatiale constante influençant la densité de biomasse, mais non pris en compte dans le modèle.  
Exemple : Profondeur, type de substrat si non inclus dans le modèle.  
Ces champs aléatoires spatiaux absorbent la structure spatiale non expliquée (par la profondeur) et réduisent généralement l’autocorrélation spatiale résiduelle.  
Utiliser pour visualiser les déviations spatiales persistantes. 

<br/>

omega_s < 0 : densité plus faible que ce que les covariables prédisent (les covariables ne suffisent pas à expliquer la faible densité observée)  
omega_s ≈ 0 : pas d'effet spatial important --> densité prévisible par les variables environnementales mesurées  
omega_s > 0 : densité plus élevée que ce que les covariables prédisent (habitat favorable - de manière stable dans le temps-)  


<br/>
<br/>
<br/>

```{r echo=FALSE}

if (response == "presence_absence" || distribution_family == "tweedie") {               

ggplot(pred_fit, aes(lon, lat, fill = epsilon_st)) + 
  geom_raster() +
  facet_wrap(~year) +
  geom_sf(data=land, fill="grey80", inherit.aes = FALSE, color = "grey80") +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3))+
  scale_x_continuous(breaks = scales::pretty_breaks(n = 4))+
  scale_fill_gradient2(labels = scales::label_number(drop0trailing = TRUE))+
  coord_sf(xlim = c(xmin_plot, xmax_plot), 
           ylim = c(ymin_plot, ymax_plot), 
           expand = FALSE) +
  theme(panel.grid = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA), 
        panel.border = element_rect(color = "white", fill = NA, linewidth = 2),
        strip.background = element_rect(fill = "grey40", color = "white"),
        strip.text = element_text(color = "white", face = "bold"))+
  labs(x = "", y ="", 
       title = "Effects aléatoires spatio-temporels")

}

if (response == "densityKgKm2" && distribution_family != "tweedie") {               

  ggplot(pred_fit, aes(lon, lat, fill = epsilon_st1)) + 
  geom_raster() +
  facet_wrap(~year) +
  geom_sf(data=land, fill="grey80", inherit.aes = FALSE, color = "grey80") +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3))+
  scale_x_continuous(breaks = scales::pretty_breaks(n = 4))+
  scale_fill_gradient2(labels = scales::label_number(drop0trailing = TRUE))+
  coord_sf(xlim = c(xmin_plot, xmax_plot), 
           ylim = c(ymin_plot, ymax_plot), 
           expand = FALSE) +
  theme(panel.grid = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA), 
        panel.border = element_rect(color = "white", fill = NA, linewidth = 2),
        strip.background = element_rect(fill = "grey40", color = "white"),
        strip.text = element_text(color = "white", face = "bold"))+
  labs(x = "", y ="", 
       title = "Effects aléatoires spatio-temporels")

}

```

```{r echo=FALSE}

if (response == "densityKgKm2" && distribution_family != "tweedie") {               

  ggplot(pred_fit, aes(lon, lat, fill = epsilon_st2)) + 
  geom_raster() +
  facet_wrap(~year) +
  geom_sf(data=land, fill="grey80", inherit.aes = FALSE, color = "grey80") +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3))+
  scale_x_continuous(breaks = scales::pretty_breaks(n = 4))+
  scale_fill_gradient2(labels = scales::label_number(drop0trailing = TRUE))+
  coord_sf(xlim = c(xmin_plot, xmax_plot), 
           ylim = c(ymin_plot, ymax_plot), 
           expand = FALSE) +
  theme(panel.grid = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA), 
        panel.border = element_rect(color = "white", fill = NA, linewidth = 2),
        strip.background = element_rect(fill = "grey40", color = "white"),
        strip.text = element_text(color = "white", face = "bold"))+
  labs(x = "", y ="", 
       title = "Effects aléatoires spatio-temporels")

}
```

<br/>

Les effets aléatoires spatio-temporels représentent les effets spatialement corrélés provenant de variables qui changent dans le temps mais sont omises du modèle (déviations par rapport aux prédictions des effets fixes et aux déviations des effets aléatoires spatiaux).  
Exemple : Température, oxygène, abondance des proies si non inclus dans le modèle.  
Ces déviations reflètent des facteurs biotiques et abiotiques à structure spatiale qui évoluent dans le temps et qui ne sont pas pris en compte dans le modèle.  
Utiliser pour observer les anomalies spécifiques à chaque année.  

<br/>

epsilon_st < 0 : l’année est défavorable à cet endroit : baisse de densité par rapport à la moyenne spatiale  
epsilon_st ≈ 0 : pas de variation significative : année proche de la moyenne  
epsilon_st > 0 : l’année est  favorable : hausse de densité à cet endroit  

<br/>
<br/>



```{r}

if (isTRUE(depth_FE) && !isTRUE(gear_factor_FE)) {    
  
  d <- visreg::visreg(model, xvar = "depth", scale = "response",  plot = FALSE)
  
  ggplot(d$fit, aes(x = depth, y = visregFit)) +
    geom_line() +
    geom_ribbon(aes(ymin = visregLwr, ymax = visregUpr), alpha = 0.5) +
    labs(x="Profondeur (m)", y="Densité (kg/km²)", 
         title = "Effet conditionnel de la profondeur sur la densité réelle\n(en maintenant toutes les autres variables constantes)") +
    theme_minimal() 

}
```



# 6. Série temporelle, indice
```{r}

if (!response == "presence_absence" && isTRUE(year_factor_FE)) {
  
 pred_fit_index <- predict(model, newdata = grid_pred,
                          return_tmb_object = TRUE)

index <- get_index(pred_fit_index, 
                   bias_correct = TRUE, 
                   level = 0.95, 
                   area = (res_km*res_km), 
                   silent = TRUE)


index$year_num <- as.numeric(as.character(index$year))  

ggplot(index, aes(x = year_num, y = est/1000, group = 1)) +
  geom_line() +
  geom_ribbon(aes(ymin = lwr/1000, ymax = upr/1000), alpha = 0.4) +
  coord_cartesian(ylim = c(0, NA)) +
  scale_x_continuous(breaks = 2018:2024) +
  labs(x = "Year", y = "Biomasse (tonnes)",
       title = "Biomasse annuelle totale prédite sur toute la zone") +
  theme_minimal()


}

```




